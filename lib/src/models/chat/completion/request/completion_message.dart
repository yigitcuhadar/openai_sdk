import 'package:json_annotation/json_annotation.dart';

import 'tool_call.dart';
import 'user_message_content.dart';

part 'completion_message.g.dart';

sealed class CompletionMessageBase {
  /// The role of the messages author.
  final String role;

  const CompletionMessageBase({
    required this.role,
  });

  factory CompletionMessageBase.fromJson(Map<String, dynamic> json) {
    if (json['role'] == 'system') {
      return CompletionSystemMessage.fromJson(json);
    } else if (json['role'] == 'user') {
      return CompletionUserMessage.fromJson(json);
    } else if (json['role'] == 'assistant') {
      return CompletionAssistantMessage.fromJson(json);
    } else {
      return CompletionToolMessage.fromJson(json);
    }
  }

  Map<String, dynamic> toJson();
}

@JsonSerializable(fieldRename: FieldRename.snake, includeIfNull: false)
class CompletionSystemMessage extends CompletionMessageBase {
  /// The contents of the system message.
  /// TODO string or array???
  final String content;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  final String? name;

  const CompletionSystemMessage({
    required this.content,
    super.role = 'system',
    this.name,
  });

  factory CompletionSystemMessage.fromJson(Map<String, dynamic> data) => _$CompletionSystemMessageFromJson(data);
  @override
  Map<String, dynamic> toJson() => _$CompletionSystemMessageToJson(this);
}

class CompletionUserMessage extends CompletionMessageBase {
  /// The contents of the user message.
  final String? textContent;
  final List<UserMessageContentBase>? listContent;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  final String? name;

  const CompletionUserMessage.textContent({
    required this.textContent,
    super.role = 'user',
    this.name,
  }) : listContent = null;

  const CompletionUserMessage.listContent({
    required this.listContent,
    super.role = 'user',
    this.name,
  }) : textContent = null;

  factory CompletionUserMessage.fromJson(Map<String, dynamic> data) {
    if (data['content'] is String) {
      return CompletionUserMessage.textContent(
        textContent: data['content'] as String,
        role: data['role'] as String? ?? 'user',
        name: data['name'] as String?,
      );
    } else {
      return CompletionUserMessage.listContent(
        listContent:
            (data['content'] as List<dynamic>).map((e) => UserMessageContentBase.fromJson(e as Map<String, dynamic>)).toList(),
        role: data['role'] as String? ?? 'user',
        name: data['name'] as String?,
      );
    }
  }

  @override
  Map<String, dynamic> toJson() => {
        if (textContent != null) 'content': textContent,
        if (listContent != null) 'content': listContent,
        'role': role,
        if (name != null) 'name': name,
      };
}

@JsonSerializable(fieldRename: FieldRename.snake, includeIfNull: false)
class CompletionAssistantMessage extends CompletionMessageBase {
  /// The contents of the assistant message. Required unless tool_calls or function_call is specified.
  /// TODO string or array???
  final String? content;

  /// The refusal message by the assistant.
  final String? refusal;

  /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  final String? name;

  /// The tool calls generated by the model, such as function calls.
  @JsonKey(name: 'tool_calls')
  final List<ToolCall>? toolCalls;

  const CompletionAssistantMessage({
    this.content,
    this.refusal,
    super.role = 'assistant',
    this.name,
    this.toolCalls,
  });

  factory CompletionAssistantMessage.fromJson(Map<String, dynamic> data) => _$CompletionAssistantMessageFromJson(data);
  @override
  Map<String, dynamic> toJson() => _$CompletionAssistantMessageToJson(this);
}

@JsonSerializable(fieldRename: FieldRename.snake, includeIfNull: false)
class CompletionToolMessage extends CompletionMessageBase {
  /// The contents of the tool message.
  /// TODO string or array???
  final String content;

  /// Tool call that this message is responding to.
  @JsonKey(name: 'tool_call_id')
  final String toolCallId;

  const CompletionToolMessage({
    super.role = 'tool',
    required this.content,
    required this.toolCallId,
  });

  factory CompletionToolMessage.fromJson(Map<String, dynamic> data) => _$CompletionToolMessageFromJson(data);
  @override
  Map<String, dynamic> toJson() => _$CompletionToolMessageToJson(this);
}
